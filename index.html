<!doctype html>
<html lang="pt">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Alma — entrada</title>
<style>
  :root{ --bg:#0b0b0c; --fg:#f2f3f7; --muted:#a9afbb; --accent:#c79300; --border:#23252b; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);
       font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:0 auto;padding:28px 16px;display:flex;flex-direction:column;align-items:center}

  .stage{width:clamp(320px,36vw,520px);height:clamp(260px,36vw,420px);
         position:relative;margin:6px auto 0; border-radius:18px; overflow:hidden}
  #canvas{position:absolute;inset:0}
  .spinner{position:absolute;inset:0;display:grid;place-items:center}
  .spinner::before{content:"";width:40px;height:40px;border-radius:50%;
    border:4px solid rgba(199,147,0,.25);border-top-color:var(--accent);animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}
  .err{position:absolute;inset:0;display:none;place-items:center;color:#ff9c9c;font-size:14px}

  .typewrap{width:min(1000px,100%); margin:18px auto 0; text-align:center}
  .type{font-weight:900; letter-spacing:-0.5px; line-height:1.06;
        font-size:clamp(34px,7vw,76px); white-space:pre-wrap; margin:0}
  .type .prompt{opacity:.6}
  .cursor{display:inline-block;width:.6ch;background:currentColor;animation:blink 1s steps(1,end) infinite}
  @keyframes blink{50%{opacity:0}}

  .tiles{width:min(1100px,100%);display:grid;grid-template-columns:repeat(3,1fr);
         gap:16px;margin:22px auto 8px}
  @media (max-width:900px){ .tiles{grid-template-columns:1fr} }
  .tile{display:flex;flex-direction:column;gap:6px;padding:18px;border-radius:14px;
        background:linear-gradient(180deg,#101114,#15171b);border:1px solid var(--border);
        text-decoration:none;color:var(--fg);transition:border-color .15s ease}
  .tile:hover{border-color:var(--accent)}
  .tile h3{margin:0 0 4px 0;font-size:18px}
  .tile p{margin:0;color:var(--muted);font-size:14px}
</style>

<script type="module" src="https://unpkg.com/three@0.160.1/build/three.module.js"></script>
<script type="module" src="https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js"></script>
</head>
<body>
<div class="wrap">
  <section class="stage" aria-label="Alma avatar 3D">
    <canvas id="canvas"></canvas>
    <div class="spinner" id="spin"></div>
    <div class="err" id="err">⚠️ Não consegui carregar o avatar.</div>
  </section>

  <div class="typewrap">
    <h1 class="type" id="type"><span class="prompt">&gt; </span></h1>
  </div>

  <nav class="tiles">
    <a class="tile" href="/alma-chat"><h3>Escrever com a Alma</h3><p>Chat em modo consola, rápido e minimal.</p></a>
    <a class="tile" href="/alma-frontend"><h3>Falar com a Alma</h3><p>Voz→voz e texto→voz, com lipsync.</p></a>
    <a class="tile" href="/console"><h3>Adicionar ao Alma Data</h3><p>Sitemaps, páginas, PDFs e texto para o RAG.</p></a>
  </nav>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';

  // ---------- CONFIG ----------
  const qs = new URLSearchParams(location.search);
  const AVATAR_URL = qs.get('avatar')
    || 'https://models.readyplayer.me/68ac391e858e75812baf48c2.glb?morphTargets=ARKit';
  const TYPE_TEXT = "Olá, sou a Alma";

  // ---------- TYPEWRITER ----------
  const typeEl = document.getElementById('type');
  let typedOnce = false;
  function startTypewriter(){
    if (typedOnce) return; typedOnce = true;
    let i=0;
    (function tick(){
      if (i <= TYPE_TEXT.length){
        typeEl.innerHTML = `<span class="prompt">&gt; </span>${TYPE_TEXT.slice(0,i)}<span class="cursor">&nbsp;</span>`;
        i++; setTimeout(tick, i<3 ? 120 : 42);
      } else {
        typeEl.innerHTML = `<span class="prompt">&gt; </span>${TYPE_TEXT}`;
      }
    })();
  }

  // ---------- HELPERS ----------
  const lerp = (a,b,t)=> a + (b-a)*Math.max(0,Math.min(1,t));
  function findMorphIndex(mesh, names){
    if (!mesh.morphTargetDictionary) return -1;
    for (const n of names){ const i=mesh.morphTargetDictionary[n]; if (typeof i==='number') return i; }
    return -1;
  }
  function fitCameraToObject(camera, object, renderer,
    {padding=0.95,yFocusBias=0.72,zoomFactor=0.58}={}
  ){
    const box = new THREE.Box3().setFromObject(object);
    const size = new THREE.Vector3(); const center = new THREE.Vector3();
    box.getSize(size); box.getCenter(center);
    const target = center.clone(); target.y += size.y*(yFocusBias-0.5);

    const fov = (camera.fov*Math.PI)/180;
    const height = size.y*padding, width=size.x*padding;
    const distH = height/(2*Math.tan(fov/2));
    const distW = width /(2*Math.tan((fov*camera.aspect)/2));
    const dist = Math.max(distH,distW)*zoomFactor;

    const dir = new THREE.Vector3(0,0.12,1).normalize();
    const pos = target.clone().add(dir.multiplyScalar(dist));
    camera.position.copy(pos);
    camera.near=Math.max(0.01,dist/100); camera.far=dist*100; camera.updateProjectionMatrix();
    camera.lookAt(target); renderer.render(object.parent||scene,camera);
  }

  // ---------- SCENE ----------
  const stage = document.querySelector('.stage');
  const canvas = document.getElementById('canvas');
  const spin = document.getElementById('spin');
  const errBox = document.getElementById('err');

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(0,1.6,2.0);

  function resize(){
    const w = stage.clientWidth, h = stage.clientHeight;
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
    if (avatarGroup) fitCameraToObject(camera, avatarGroup, renderer);
  }
  // Evitar múltiplos handlers
  window.addEventListener('resize', resize, { passive:true, once:false });

  scene.add(new THREE.HemisphereLight(0xffffff,0x222233,1.0));
  const d = new THREE.DirectionalLight(0xffffff,1.0); d.position.set(2,4,2); scene.add(d);

  // ---------- LOAD AVATAR (guardas anti-loop) ----------
  const loader = new GLTFLoader(); loader.setCrossOrigin('anonymous');
  let avatarGroup=null, exprMeshes=[], idxSmileL=[], idxSmileR=[];
  let loadedOnce=false, spunOnce=false;

  function beginIntroOnce(){
    if (spunOnce || !avatarGroup) return; spunOnce = true;
    avatarGroup.rotation.y = -Math.PI*0.90;
    const t0 = performance.now(); const dur = 1100;
    (function spinIn(){
      const t = Math.min(1,(performance.now()-t0)/dur);
      const e = 1 - Math.pow(1-t,3);
      avatarGroup.rotation.y = -Math.PI*0.90*(1-e);
      for (let i=0;i<exprMeshes.length;i++){
        const infl = exprMeshes[i].morphTargetInfluences;
        if (idxSmileL[i]>=0) infl[idxSmileL[i]] = lerp(infl[idxSmileL[i]]||0, 0.35*e, 0.25);
        if (idxSmileR[i]>=0) infl[idxSmileR[i]] = lerp(infl[idxSmileR[i]]||0, 0.35*e, 0.25);
      }
      if (t<1) requestAnimationFrame(spinIn);
      else { spin.style.display='none'; startTypewriter(); }
    })();
  }

  function loadAvatarOnce(){
    if (loadedOnce) return; loadedOnce = true;

    loader.load(
      AVATAR_URL,
      (gltf)=>{
        const avatar = gltf.scene;
        avatar.traverse((o)=>{
          const n=(o.name||'').toLowerCase();
          if (n.includes('hand')||n.includes('wrist')||n.includes('wolf3d_hands')) o.visible=false;
          if (o.isMesh && o.material?.isMeshStandardMaterial){ o.material.roughness=0.75; o.material.metalness=0.05; }
        });

        // normalização e recentragem
        const box = new THREE.Box3().setFromObject(avatar);
        const size = new THREE.Vector3(); const min = new THREE.Vector3(); const ctr = new THREE.Vector3();
        box.getSize(size); box.getMin(min); box.getCenter(ctr);
        avatar.scale.setScalar(1.75/(size.y||1));
        avatar.position.x -= ctr.x; avatar.position.z -= ctr.z; avatar.position.y -= min.y;

        avatarGroup = new THREE.Group(); avatarGroup.add(avatar); scene.add(avatarGroup);

        exprMeshes=[]; idxSmileL=[]; idxSmileR=[];
        avatar.traverse((obj)=>{
          if (obj.isMesh && obj.morphTargetDictionary && obj.morphTargetInfluences){
            const sL = findMorphIndex(obj, ["mouthSmileLeft","smileLeft","MouthSmileLeft"]);
            const sR = findMorphIndex(obj, ["mouthSmileRight","smileRight","MouthSmileRight"]);
            if (sL>=0 || sR>=0){ exprMeshes.push(obj); idxSmileL.push(sL); idxSmileR.push(sR); }
          }
        });

        resize();           // ajusta à caixa atual
        beginIntroOnce();   // anima 1x
      },
      undefined,
      (err)=>{ console.warn('Falha GLB:', err); spin.style.display='none'; errBox.style.display='grid'; startTypewriter(); }
    );
  }

  // arranque
  resize();
  loadAvatarOnce();

  // render loop único
  (function RAF(){ renderer.render(scene,camera); requestAnimationFrame(RAF); })();

  // ---------- WARM-UP (sem retries, sem heygen) ----------
  (async ()=>{
    try{ await fetch('/health',{cache:'no-store'}); }catch{}
    try{
      await fetch('/ask',{method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({question:'ping',user_id:'warmup'})});
    }catch{}
    // best-effort para o frontend; não repetimos
    fetch('/api/stt',{method:'OPTIONS'}).catch(()=>{});
    fetch('/api/tts',{method:'OPTIONS'}).catch(()=>{});
  })();
</script>
</body>
</html>
